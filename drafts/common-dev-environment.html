<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <title>Arnaud Bailly - Team Practices: Shared Development Environment</title>
  <meta name="description" content="We craft code">
  <meta name="author" content="Arnaud Bailly, Thomas Queste">

  <link rel="stylesheet" type="text/css" href="/css/style.css?v=3">
  <link rel="stylesheet" type="text/css" href="/css/default.css">
  <link rel="stylesheet" type="text/css" href="/css/syntax.css">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Lato">
  <script src="/js/modernizr-2.0.6.min.js"></script>
</head>
<body>
  <div id="container">
    <header>
      <div id="company-title">
        <a href="http://abailly.github.io"><img id="company-logo" src="/images/logo.png" width="259" height="75" title="igitur.io" /></a>
      </div>
      <div>
        <nav class="clearfix">
        <ul id="menu">
          <li>
          <a href="#">About</a>
          </li>
        </ul>
        </nav>
      </div>
    </header>
    <div class="draft" id="main" role="main">
<h1>Team Practices: Shared Development Environment</h1>

  <h2 class="subtitle"></h2>

<div class="info">Posted on October 15, 2020</div>

<p>This is another post in a series I plan to write on interesting team-wide practices I have found and still find to be effective to further and support <em>eXtreme Programming</em>. In this post, I present how I try to promote <em>Collective Code Ownership</em> and <em>Coding Standards</em> to a new level through the use of a <em>Shared Development Environment</em>. The goal is to ensure as much standardization in the process and tools from design to deployment, in order to avoid the all too common <em>“Works on my machine”</em> syndrom that plagues software development team.</p>
<h1 id="the-need-for-standardization">The need for standardization</h1>
<h2 id="coding-standards">Coding Standards</h2>
<p>The usual approach to <em>Coding Standards</em> is to provide guidelines to the code writing part of the process. In the past, these took the form of extensive <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">Coding style guides</a> but as our tools mature, more and more standards can and are implemented as automated checks that are run as part of the software deployment pipeline. <a href="https://www.sonarqube.org/">SonarQube</a> is one of the many tools that encodes coding standards, best practices, and rules. One thing to note is that coding standards encompass a wide range of different activities and code artefacts, from lexical and syntactic rules to design principles, through naming conventions and prescriptions. There are probably things which are not amenable to automation but there’s nevertheless a relentless effort from practitioners and researchers alike to <em>Automate all The Things</em>, and verify things like <a href="https://innig.net/macker/guide/">software architecture</a> or <a href="https://lgtm.com/">security</a>.</p>
<p>There is one particular area where standardization, across a team or even a whole programming environment, should be enforced: The code’s formatting rules. There has been, and will be, endless discussions between developers on such critically important topics as where to put curly braces, whether or not to use tabulations or spaces for indentation, how much space to put in various places of the code, etc. These discussions are a source of considerable bikeshedding, waste of time, and contribute exactly <em>zero</em> value to the end product; automating application of standard code format <a href="https://prettier.io/docs/en/precommit.html">before commit</a> or, even better, before <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Standard-Hooks.html">saving files</a>.</p>
<p>However, this is dependent on the particular setup of each development environment and various problems might arise:</p>
<ul>
<li>The rules might be encoded in different tools to support different IDEs, which necessarily will lead to differences cropping up,</li>
<li>There might not be an overall agreed upon set of rules for the language which makes it hard for the team to settle the question,</li>
<li>The language itself might be hardly amenable to <a href="http://modernperlbooks.com/mt/2009/08/on-parsing-perl-5.html">parsing</a> and pretty-printing,</li>
<li>…</li>
</ul>
<p>I thus view as a great step forward that some formatting tools decide to provide no configuration options, like the <a href="https://github.com/google/google-java-format">google-java-format</a> for Java, <a href="https://hackage.haskell.org/package/ormolu">Ormolu</a>, <a href="https://github.com/avh4/elm-format">elm-format</a> for Elm, or <a href="https://golang.org/cmd/gofmt/">gofmt</a> for Go. The next logical step would be for the compiler itself to enforce the formatting rules<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> and only accept programs in <em>Normal Form</em>: This would guarantee a uniform layout across all code bases using this language and would have the added advantage of greatly simplifying parsing and more generally development of tools to manipulate the language.</p>
<h2 id="collective-code-ownership">Collective Code Ownership</h2>
<p><em>Collective Code Ownership</em> is that XP practice which strives to make <em>all</em> parts of the code collectively owned, meaning that every team member has the right and the duty to work on the whole software stack, there is no “preserve” that would be exclusive to some team members for reasons of skills, purpose, sensitivity, or seniority. A corollary to this strong statement is that every team member should feel at ease in every part of the code, and be able to understand what’s going on and make relevant changes and improvements in a way that any other team member can vouch for it.</p>
<p><em>Pair Programming</em> or <em>Mob Programming</em> are XP practices which are conducive to building such a collectively shared understanding of the code, much more so than <em>Pull Requests</em> or <em>Code Reviews</em><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. But they are only effective if all the people coding together can actually do so effectively and efficiently: If I pair program with an expert Vim golfer and I drive, then chances are I will be very slow and clumsy, at least initially; it will take time for me to get accustomed to my mate’s development environment, to use his or her keyboard shortcuts, commands, links, productively. And this is not specific to Vim of course, cognitive dissonance can come from every part of the environment: The keyboard (Dvorak/Colemak/Qwerty/Azerty/Bépo), the OS (Mac/Windows/flavors of Linux), the language settings, the window manager (tiling/non-tiling), the shell (Bash/fish/zsh), the IDE (VS/VS Code/IDEA/Eclipse), the color settings (dark vs. light colors, small vs. large screens) are all potential sources of pain for the newcomer.</p>
<p><em>Collective Code Ownership</em> should be understood not only as an imperative to share understanding of the code but also to share understanding, knowledge, and skills of the <em>tools</em> to produce and work on that code. Everyone has his or her own idiosyncrasies, preferences, disgusts, personal history that accumulate over time and cristallize in specific tools and environment we feel comfortable with. And this is of course totally fine. But this should not come in the way of building an <em>inter-subjective experience</em> of the code: If we all insist on viewing and manipulating the code through our own private lenses, chances are we will fail in developing any form of shared understanding, vision, comprehensive knowledge of the code.</p>
<h1 id="building-shared-environment">Building Shared environment</h1>
<p>Working remotely is actually a great opportunity to outflank the obstacle of particularism and build a <em>Shared Development Environment</em> that is pre-configured <em>virtual machines</em> (or <em>containers</em>) that provide a standardised development environment shareable across the team. The idea hinges on <a href="https://en.wikipedia.org/wiki/Infrastructure_as_code">Infrastructure as Code</a> principles: Manage the infrastructure supporting the <em>process</em> using the same tools and principles with which we manage the <em>product</em>, but one step beyond. Do not only manage the production infrastructure, but also the development infrastructure, so that the whole stack of tools used to produce the code is shared by everyone, versioned in the source code, deployable at will.</p>
<p>Here is a description of the environment we have built in my previous teams.</p>
<h2 id="defining-the-image">Defining the image</h2>
<p>The first step is to define the virtual machine image. This we do using Hashicorp’s <a href="https://www.packer.io/">Packer</a> which provides a way to build VM images deployable to most major clouds (at least I have tried GCP and AWS). Packer is configured with a JSON file that looks the following (I have shown only the configuration for building a GCP image):</p>
<pre><code>{
    &quot;builders&quot;: [
        {
            &quot;type&quot;: &quot;googlecompute&quot;,
            &quot;account_file&quot;: &quot;google-keys.json&quot;,
            &quot;project_id&quot;: &quot;my-project&quot;,
            &quot;source_image&quot;: &quot;ubuntu-1804-bionic-v20190212a&quot;,
            &quot;ssh_username&quot;: &quot;curry&quot;,
            &quot;image_family&quot;: &quot;build&quot;,
            &quot;image_name&quot;: &quot;build-{{timestamp}}&quot;,
            &quot;zone&quot;: &quot;eu-west1-b&quot;
        }
    ],
    &quot;provisioners&quot;: [{
    &quot;type&quot;: &quot;shell&quot;,
        &quot;inline&quot;: [
            &quot;sleep 30&quot;
        ]
    },{
        &quot;type&quot;: &quot;shell&quot;,
        &quot;script&quot;: &quot;build-env.sh&quot;
    }]
}</code></pre>
<p>There are much more sophisticated options to configure the image than using a plain shell script but this is sufficient for our needs. I won’t go into the details of the script here but it is pretty straightforward: It installs all the tools we need for development, which in this case includes docker, gcloud tools, and a whole bunch of utilities like curl, git, tmux, graphviz, wget, jq, python3, bzip2, neovim, ag… We were using Emacs (or rather <a href="https://www.spacemacs.org/">spacemacs</a>) so it was also part of the installed packages.</p>
<p>Running <code>packer build build.json</code> will build a new image with the given name ready to be deployed over the configured infrastructure providers.</p>
<h2 id="defining-infrastructure">Defining infrastructure</h2>
<p>The most interesting part is the definition of the infrastructure itself, which uses <a href="https://www.terraform.io/">Terraform</a>. The set of <code>.tf</code> files is interpreted by the terraform tool, it checks the consistency of the defined infrastructure, and compares it with the latest known persistent state drawn from cloud storage, to decide what to do: Create, delete or modify various components of the infrastructure.</p>
<p>There is a module defining the standard configuration of a development VM:</p>
<pre><code>variable &quot;name&quot; {
  description = &quot;The name of the machine.&quot;
}

variable &quot;ssh_keys&quot; {
  description = &quot;The file containing ssh_keys.&quot;
}</code></pre>
<p>The variable <code>ssh_keys</code> contains the name of a file which lists the public keys of people who can access the machine. This makes it possible to control who can access the devlopment environment through a file <em>committed</em> to the version control repository.</p>
<pre><code>output &quot;address&quot; {
  value = &quot;${google_compute_address.dev-address.address}&quot;
}

resource &quot;google_compute_address&quot; &quot;dev-address&quot; {
  name = &quot;${var.name}-address&quot;
}</code></pre>
<p>This <code>output</code> variable will show the IP address of the VM once it’s deployed, so we need to allocate a public IP address for this machine.</p>
<pre><code>resource &quot;google_compute_instance&quot; &quot;dev&quot; {
  name                      = &quot;${var.name}&quot;
  machine_type              = &quot;n2-standard-8&quot;
  zone                      = &quot;eu-west1-c&quot;
  allow_stopping_for_update = true

  tags = [ &quot;dev&quot;]

  boot_disk {
    auto_delete = true

    initialize_params {
      size  = 200
      image = &quot;build/build-1546597455&quot;
    }
  }

  network_interface {
    network = &quot;default&quot;

    access_config {
      nat_ip = &quot;${google_compute_address.dev-address.address}&quot;
    }
  }

  metadata {
    sshKeys = &quot;${file(var.ssh_keys)}&quot;
  }

  service_account {
    email  = &quot;build@my-project.iam.gserviceaccount.com&quot;
    scopes = [&quot;compute-rw&quot;, &quot;storage-rw&quot;, &quot;https://www.googleapis.com/auth/cloudkms&quot;]
  }</code></pre>
<p>This sets the core features of our VM: Machine type, location, boot disk size… The <code>sshKeys</code> metadata reads its content from the file we defined earlier, and the <code>service_Account</code> definition requests the creation of a new service account with the given authorizations.</p>
<pre><code>  provisioner &quot;file&quot; {
    source      = &quot;dev/bash_aliases&quot;
    destination = &quot;/home/curry/.bash_aliases&quot;

    connection {
      type = &quot;ssh&quot;
      user = &quot;curry&quot;
    }
  }
# ...
# more filea uploaded
# ...
  provisioner &quot;file&quot; {
    source      = &quot;dev/configure.sh&quot;
    destination = &quot;/home/curry/configure.sh&quot;

    connection {
      type = &quot;ssh&quot;
      user = &quot;curry&quot;
    }
  }</code></pre>
<p>We then upload configuration files (aka. <em>dotfiles</em>) which are also versioned and stored in the source tree, including configuration for the shell, the <a href="https://github.com/tmux/tmux/wiki">tmux</a>, emacs, and a configuration script.</p>
<pre><code>  provisioner &quot;remote-exec&quot; {
    inline = [
      &quot;chmod +x /home/curry/configure.sh&quot;,
      &quot;/home/curry/configure.sh&quot;,
    ]

    connection {
      type = &quot;ssh&quot;
      user = &quot;curry&quot;
    }
  }
}</code></pre>
<p>And finally we execute the configuration script that’s responsible for retrieving the source code, possibly cached build artifacts, and last minute configuration steps. There are a lot of possible variations on this baseline but the end goal is to ensure the team has at its disposal development environments which everyone can use and which are guaranteed to be consistently configured, thus making pair and mob programming session simple and easy to setup.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In this post I have motivated why a shared development environment is desirable and useful, and demonstrated how easily it can be set up using basic IAAC tools. This practice can also be very useful in more complicated settings. I am working in a team which has to maintain a legacy piece of software built using a 4GL IDE called <a href="https://en.wikipedia.org/wiki/PowerBuilder">PowerBuilder</a>, which is only available on Windows. One of the first things I did when joining the team was to create a couple of VMs on Azure cloud with several tools installed, including the PowerBuilder IDE, SQL Management Studio, Git, in order to make it straightforward to work collaboratively on the code. The experience is not quite as smooth as sharing a terminal through tmux or tmate, but it’s still only take a few seconds to switch driver/navigator roles: Simply log into the VM and share screen. Not being an expert in Windows automation I have not yet go beyond documenting the manual steps needed to configure the machine but this is only a matter of investing some time or finding the right person to help me.</p>
<p>Sharing the development environment is something that requires negotiation within the team, and that takes time to grow. Team members need to overcome their personal preferences and accept the discomfort of coding in an environment to which they might not be, at least initiall, a hundred percent atuned to. The goal is not to impose <em>The One True Way</em> but on the contrary to share the knowledge and take the best that each setup has to offer. A versioned and pre-configured VM can perfectly host <em>both</em> Emacs and Vim, or can expose a VNC server that makes it easier to share graphical tools, or basically offer any kind of environment.</p>
<p>The key benefit of standardisation of the development tools can also be extended to <em>Continuous Integration</em> by sharing configuration of the machines between development and CI VMs.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I thought this was the case for Elm and Go but it seems they do not still fail to compile ill-formatted source code.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>As my friend Christophe Thibaut used to say: “Code reviews is Pair programming for people who don’t fully trust each other”<a href="#fnref2">↩</a></p></li>
</ol>
</div>


<div id="disqus_thread"></div>
<script>
  (function() {  // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
  
    s.src = '//arnaudsblog.disqus.com/embed.js';
  
    s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



    </div>
    <footer>
       <a href="https://fr.linkedin.com/in/arnaudbailly"> <img src="/images/linkedin.png" width="28" /></a>  <a href="https://twitter.com/abailly"> <img width="32" src="/images/twitter.png" /></a>  <a href="/atom.xml"><img src="/images/feed-icon.svg" width="24px" /></a>  <a href="http://jaspervdj.be/hakyll"><img src="/images/lambda.png" width="24px" /></a>
    </footer>
  </div>
</body>
</html>
