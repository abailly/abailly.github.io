---
title: Maîtriser le code légataire
author: Arnaud Bailly
date: 2013-04-25
---

Durant ces deux journées de formation, vous apprendrez à améliorer la
conception d'un logiciel pas à pas, tout en continuant à produire de
la valeur pour vos clients.

Tout le monde voudrait un logiciel qui fonctionne parfaitement, qui
soit un plaisir à maintenir et faire évoluer. En pratique, il y a
toujours des bugs à corriger et des clients à satisfaire
rapidement. Des raccourcis sont pris et la dette technique s'accumule
produisant in fine du *code légataire* : du code sans tests.

Vous voudriez améliorer le code petit à petit, le *refactorer* c'est à
dire améliorer sa conception sans toucher à son comportement. Mais
c'est le dilemme de l'oeuf et de la poule: pour *refactorer*
sereinement, il faut des tests automatisés qui préviennent les
régressions. Pour ajouter des tests, il d'abord rendre le code
modulaire en le *refactorant* !

Tout espoir n'est pas perdu ! Au travers de présentations, de
démonstrations et d'exercices, d'étude de case, vous apprendrez à
identifier les "mauvaises odeurs", briser les dépendances,
*refactorer* et ajouter des tests sur du code légataire chaotique, de
manière à pouvoir ajouter de nouvelles fonctionnalités avec facilité
et confiance.

Les techniques apprises dans cette formation sont aussi utiles pour
les nouveaux projets afin de prévenir leur transformation en code
légataire. Elles vous permettent de réparer rapidement vos erreurs et
d'empêcher qu'elles ne se reproduisent.

## Benefits


A l'issu de ce cours, vous saurez:

* utiliser différentes techniques pour briser les dépendances
  indésirables dans le code ;
* commencer à changer du code et ajouter des tests simplement et de
  manière responsable ;
* identifier la dynamique systémique d'accumulation de la dette
  technique ;
* prioriser, planifier et exécuter un *refactoring* d'importance en
  équipe sur une base de code significative grâce à une étude de cas
  complète ;
* mettre en oeuvre des techniques simples de pas-à-pas sécurisé: pomodoro,
  technique du mikado, gestion de versions

## Méthodes ##

Nous mettons un point d'honneur à faire en sorte que les participants
à nos formations vivent une expérience riche, intense et varié. Pour
ce faire, nous utilisons différents supports (web, présentation,
papier) et surtout beaucoup d'ateliers et de cas pratiques,
d'exercices, de simulations.

Nous avons aussi à coeur d'ajuster la formation aux besoins et
attentes réels du public et c'est pourquoi une *rétrospective* a lieu
à la fin de chaque journée pour afin de donner l'occasion aux
participants d'ajuster le contenu.

## Public ##

Développeurs, architectes, chefs de projet techniques, testeurs,
*coaches* agiles souhaitant améliorer leur connaissance du refactoring
et leur capacité à livrer du code "propre".

## Pré-requis ##

* Programmation orientée objet ;
* Expérience dans un langage de POO tel que Java, C#, C++, Ruby,
  Python, Smalltalk...
* Expérience, même légère, de gestion d'un projet de développement ;
* Connaissance de base du test unitaire automatisé
* Les exercices pratiques se feront en Java ou Javascript

## Programme ##

Cette formation intensive s'étend sur deux jours.

### Jour 1 ###

* Introduction aux techniques de *refactoring*, aux *odeurs* du code
et à la coupure des dépendances par la détection des "coutures" dans
le code. Cette introduction se fera par un mélange de de
présentations, démonstrations et exercices pratiques.
* Compréhension du cycle des  causes  et effets systémiques produisant
  du code légataire, afin d'être à même de sortir du cercle vicieux

### Jour 2 ###

Le deuxième jour est entièrement consacré à la pratique sur un cas
concret. Nous planifierons et exécuterons un *refactoring* important
sur un système réel. Les participants seront encadrés pour appliquer
les différentes techniques apprises: travailler sur une grosse base de
code sans se perdre, utiliser le vocabulaire des "odeurs", du
refactoring, des "coutures" et dépendances pour coordonner, planifier
et exécuter ce refactoring en équipe. Et le faire de manière sûre même
en l'absence initiale de tests automatisés.

| Nombre de participants | 8-12 |
| Tarif                  | 1050€/p |
| Session intra-entreprise | nous consulter |
| Langage/plate-forme  | Java, Javascript |
