<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <title>Arnaud Bailly - Adventures in Dependently Typed Accounting</title>
  <meta name="description" content="We craft code">
  <meta name="author" content="Arnaud Bailly, Thomas Queste">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Lato">
  <link rel="stylesheet" type="text/css" href="/css/style.css?v=3">
  <link rel="stylesheet" type="text/css" href="/css/default.css">
  <link rel="stylesheet" type="text/css" href="/css/syntax.css">
  <script src="/js/modernizr-2.0.6.min.js"></script>
  <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
  <div id="container">
    <header>
      <div id="company-title">
        <a href="/"><img id="company-logo" src="/images/logo.png" width="259" height="75" title="igitur.io" /></a>
      </div>
      <div>
        <nav class="clearfix">
        <ul id="menu">
          <li>
          <a href="http://drcode.io">Dr.Code</a>
          </li>
          <li>
          <a href="/about.html">About</a>
          </li>
        </ul>
        </nav>
      </div>
    </header>
    <div id="main" role="main">
<h1>Adventures in Dependently Typed Accounting</h1>

  <h2 class="subtitle"></h2>

<div class="info">Posted on September  6, 2019</div>

<blockquote>
<p>This article is the <a href="../posts/dependently-typed-date.html">third installment</a> of a series of articles exploring connection between <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a> and <a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> as implemented in <a href="http://idris-lang.org">Idris</a>. It’s been written as prepaatory work to a talk given at the <a href="https://www.meetup.com/software-craftsmanship-bdx/events/264578542/">Okiwi meetup</a> in Bordeaux.</p>
</blockquote>
<p>Although it took me more than 2 years to write a sequel to my previous post on the subject of <em>DDD + T(ype)DDD</em>, it’s a subject that I keep having in the back of my mind and something I try to apply in my day job wherever it’s possible. This time, I am investigating how to write a double-entry bookkeeping module in Idris, in the spirit of <a href="https://www.ledger-cli.org/">ledger</a> and <a href="https://hledger.org/">hledger</a>. Of course, what I wrote is nowhere near as full-featured as hledger, it’s mostly a proof-of-concept that only allows one to <em>parse</em> a ledger-formatted file and <em>pretty-prints</em> back its content.</p>
<p>What’s interesting in double-entry accounting is that it’s a “business-domain” that is relatively simple to explain and understand, grounded on some basic <em>invariants</em> that should be enforced to guarantee transactions and ledger stay consistent. This post won’t go into the details of the code which can be found in a <a href="https://github.com/abailly/xxi-century-typed/tree/master/idris/src/Accounting">github repository</a>. It’s more of a narrative on the design choices I made and what it entails to write such code in Idris, trying to highlights both the strengths of the language and its weaknesses, or its darker corners.</p>
<p>I would like to say a big “Thank you!” to the smart and friendly people from the <code>#idris</code> channel who have helped me write most of the proofs in this code, providing advices and direction on how to approach proof-writing in such a language.</p>
<h1 id="basic-concepts">Basic Concepts</h1>
<p>Here is an excerpt from <a href="https://en.wikipedia.org/wiki/Double-entry_bookkeeping_system">Wikipedia page on double-entry bookkeeping</a>:</p>
<blockquote>
<p>In the double-entry accounting system, at least two accounting entries are required to record each financial transaction. These entries may occur in asset, liability, equity, expense, or revenue accounts. Recording of a debit amount to one or more accounts and an equal credit amount to one or more accounts results in total debits being equal to total credits for all accounts in the general ledger. If the accounting entries are recorded without error, the aggregate balance of all accounts having Debit balances will be equal to the aggregate balance of all accounts having Credit balances. Accounting entries that debit and credit related accounts typically include the same date and identifying code in both accounts, so that in case of error, each debit and credit can be traced back to a journal and transaction source document, thus preserving an audit trail. The accounting entries are recorded in the “Books of Accounts”. Regardless of which accounts and how many are impacted by a given transaction, the fundamental accounting equation of assets equal liabilities plus capital will hold.</p>
</blockquote>
<p>From this description we get some basic information about the “domain” that we’ll want to implement:</p>
<ul>
<li>A <em>transaction</em> comprises at least 2 <em>entries</em></li>
<li>An <em>entry</em> records a <em>debit</em> or <em>credit</em> amount in an <em>account</em></li>
<li>An <em>account</em> can fall into 5 different categories: <em>asset</em>, <em>liability</em>, <em>equity</em>, <em>expense</em>, or <em>revenue</em></li>
<li>The aggregate debit and credit <em>balance</em> of all accounts should be equal</li>
<li>A <em>book of accounts</em> should preserve a <em>fundamental equation</em> that ensures <code>asset = liability + equity</code><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></li>
</ul>
<p>From these elements, we can start to code and first of all define the <em>types</em> we’ll need. The whole point of this series of post is to apply DDD principles to Type-Driven Development which means we want our <em>domain concepts</em> to be reflected directly into the <em>core domain</em> of our code. So we end up needing the following types:</p>
<ul>
<li>An <code>Entry</code> which contains an <code>Account</code> and some <em>amount</em> (more on this later) with a <code>Direction</code>, <code>Debit</code> or <code>Credit</code>,</li>
<li>A <code>Transaction</code> has a date, a <code>String</code> label and a list of <code>Entry</code> which must be <code>Balance</code>d,</li>
<li>A <code>BookOfAccounts</code> is a list of <code>Transaction</code>s such that the <em>fundamental equation</em> holds at all time.</li>
</ul>
<h1 id="take-1">Take 1</h1>
<p>Equipped with all this information, I started implementing the various data types, embedding the needed invariants within the definition of the types. My initial version looked like the following (see <a href="https://github.com/abailly/xxi-century-typed/blob/2c81760819f1ab1d9ba0bc101b64a168d2817bb8/idris/src/Accounting/Core.idr">Core.idr</a> for details).</p>
<h2 id="core-domain">Core Domain</h2>
<p>The <code>Balance</code> is a simple alias for a tuple of a <code>Nat</code> and a <code>Direction</code> (debit or credit) and the other core types are straightforward:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Balance</span> <span class="ot">:</span> <span class="dt">Type</span>
<span class="dt">Balance</span> <span class="fu">=</span> (<span class="dt">Nat</span>, <span class="dt">Direction</span>)

<span class="kw">data</span> <span class="dt">Account</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MkAccount</span> <span class="ot">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> { type <span class="ot">:</span> <span class="dt">AccountType</span> } <span class="ot">-&gt;</span> <span class="dt">Account</span>

<span class="kw">record</span> <span class="dt">Entry</span> <span class="kw">where</span>
  constructor <span class="dt">MkEntry</span>
  <span class="fu">amount</span> <span class="ot">:</span> <span class="dt">Balance</span>
  <span class="fu">account</span> <span class="ot">:</span> <span class="dt">Account</span></code></pre></div>
<p>Then a <code>Transaction</code> contains <code>Entries</code> of length at least 2 and with a <code>Balance</code> of <code>(0, Cr)</code>.</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Entries</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MkEntries</span> <span class="ot">:</span> (entries <span class="ot">:</span> <span class="dt">Vect</span> n <span class="dt">Entry</span>) <span class="ot">-&gt;</span>
              { <span class="kw">auto</span> need2Entries <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">2</span> n } <span class="ot">-&gt;</span>
              { <span class="kw">auto</span> balanced <span class="ot">:</span> balance entries <span class="fu">=</span> (<span class="dv">0</span>, <span class="dt">Cr</span>) } <span class="ot">-&gt;</span>
              <span class="dt">Entries</span>

<span class="kw">record</span> <span class="dt">Transaction</span> <span class="kw">where</span>
  constructor <span class="dt">Tx</span>
  <span class="fu">label</span> <span class="ot">:</span> <span class="dt">String</span>
  <span class="fu">date</span> <span class="ot">:</span> <span class="dt">Date</span>
  <span class="fu">entries</span> <span class="ot">:</span> <span class="dt">Entries</span></code></pre></div>
<p>The <code>balance</code> function computes the aggregated balance of a list of entries, taking advantage of the fact our <code>Balance</code> type is a <code>Monoid</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">balance</span> <span class="ot">:</span> <span class="dt">Vect</span> n <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">Balance</span>
balance <span class="fu">=</span>  normalise <span class="fu">.</span> concat <span class="fu">.</span> map amount</code></pre></div>
<p>The <code>normalise</code> function is needed because a 0 balance can be either a <code>Dr</code> or <code>Cr</code>. More on this later…</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">  <span class="kw">where</span>
    <span class="fu">normalise</span> <span class="ot">:</span> <span class="dt">Balance</span> <span class="ot">-&gt;</span> <span class="dt">Balance</span>
    normalise (<span class="dt">Z</span>, <span class="dt">Dr</span>) <span class="fu">=</span> neutral
    normalise bal     <span class="fu">=</span> bal</code></pre></div>
<p>And we are then ready to define our <code>BookOfAccounts</code> type to group a sequence of transactions:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">BookOfAccounts</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">BookTransactions</span> <span class="ot">:</span> (txs <span class="ot">:</span> <span class="dt">Vect</span> k <span class="dt">Transaction</span>) <span class="ot">-&gt;</span>
                     { <span class="kw">auto</span> fundamentalEquation <span class="ot">:</span> invert (assets txs <span class="fu">&lt;+&gt;</span> expenses txs) <span class="fu">=</span> liabilities txs <span class="fu">&lt;+&gt;</span> capital txs <span class="fu">&lt;+&gt;</span> revenues txs } <span class="ot">-&gt;</span>
                     <span class="dt">BookOfAccounts</span></code></pre></div>
<p>Note that we have modified the <code>fundamentalEquation</code> to take into account <code>expenses</code> and <code>revenues</code>. It is actually the case that <code>asset = liability + equity</code> only when taking into account the profit or deficit that is the difference between revenues and expenses. In actual accounting practices, a “normal” transaction always involves an expense or revenue account and one or more balance sheet account.</p>
<h2 id="testing">Testing</h2>
<p>One of the benefits of using a Type-Driven Approach in a language like Idris is that we can use the compiler/typechecker to run <em>tests</em>, instead of having to define separate test suites.</p>
<p>Given some <code>Account</code>s definitions:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Capital</span> <span class="ot">:</span> <span class="dt">Account</span>
<span class="dt">Capital</span> <span class="fu">=</span> <span class="dt">MkAccount</span> <span class="st">&quot;Capital&quot;</span> {type <span class="fu">=</span> <span class="dt">Equity</span>}

<span class="dt">Bank</span> <span class="ot">:</span> <span class="dt">Account</span>
<span class="dt">Bank</span> <span class="fu">=</span> <span class="dt">MkAccount</span> <span class="st">&quot;Bank&quot;</span> {type <span class="fu">=</span> <span class="dt">Asset</span>}</code></pre></div>
<p>We can use propositional equality, that is the <code>Type</code> asserting that two expressions are the same, as a way to assert some property holds, and then <em>prove</em> the property actually holds by providing an implementation for it that will be typechecked:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">valid1</span> <span class="ot">:</span> balance [ <span class="dt">MkEntry</span> (<span class="dv">100</span>, <span class="dt">Dr</span>) <span class="dt">Bank</span>,
                  <span class="dt">MkEntry</span> (<span class="dv">100</span>, <span class="dt">Cr</span>) <span class="dt">Capital</span> ] <span class="fu">=</span> (<span class="dv">0</span>, <span class="dt">Cr</span>)
valid1 <span class="fu">=</span> <span class="dt">Refl</span>

<span class="fu">valid2</span> <span class="ot">:</span> balance [ <span class="dt">MkEntry</span> (<span class="dv">100</span>, <span class="dt">Cr</span>) <span class="dt">Bank</span>,
                  <span class="dt">MkEntry</span> (<span class="dv">100</span>, <span class="dt">Dr</span>) <span class="dt">Capital</span> ] <span class="fu">=</span> (<span class="dv">0</span>, <span class="dt">Cr</span>)
valid2 <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Interestingly we can also state <em>negative</em> properties by proving there can never be an implementation for this type:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">invalid</span> <span class="ot">:</span> <span class="dt">Not</span> (balance [ <span class="dt">MkEntry</span> (<span class="dv">100</span>, <span class="dt">Cr</span>) <span class="dt">Bank</span>,
                         <span class="dt">MkEntry</span> (<span class="dv">101</span>, <span class="dt">Dr</span>) <span class="dt">Capital</span> ] <span class="fu">=</span> (<span class="dv">0</span>, <span class="dt">Cr</span>))
invalid <span class="fu">=</span> <span class="fu">\</span> <span class="dt">Refl</span> <span class="kw">impossible</span></code></pre></div>
<p>And those tests found a bug in my code! The order in which the entries were given in a transaction mattered as I had forgotten to recursively call the accumulation function in one case.</p>
<h2 id="parsing">Parsing</h2>
<p>Once we have our core model’s types defined, we can try to talk to the outside world. Here, we’ll simply parse a list of transactions in the <em>ledger</em> format:</p>
<pre><code>2019-01-01 Some transaction
  Asset:Bank  D 100
  Equity:Capital C 100

2019-01-02 Another transaction
  Asset:Bank C 90
  Expense:Foo D 80
  Liability:Tax D 10
</code></pre>
<p>and ensure we are able to pretty-print it in the same format.</p>
<p>I use the <a href="https://github.com/ziman/lightyear">lightyear</a> parser combinators library which is pretty-much a clone of Haskell’s parsec and is similar to every other parser combinators library out there. What’s more relevant to our purpose is the fact that the types I have defined <em>enforce</em> their invariant at the <em>constructor level</em> which means they require the calling context to provide the <em>proofs</em> those invariants are indeed valid.</p>
<p>In the <code>parseEntries</code> function for example, we need to make sure provide a sequence of the correct length (at least 2) and a proof that the entries are <em>balanced</em> in order to build an <code>Entries</code> value.</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">parseEntries</span> <span class="ot">:</span> <span class="dt">Parser</span> <span class="dt">Entries</span>
parseEntries <span class="fu">=</span> <span class="kw">do</span>
  e1 <span class="ot">&lt;-</span> parseEntry
  endOfLine
  e2 <span class="ot">&lt;-</span> parseEntry
  endOfLine
  es <span class="ot">&lt;-</span> sepBy parseEntry endOfLine
  <span class="kw">let</span> entries <span class="fu">=</span> e1 <span class="ot">::</span> e2 <span class="ot">::</span> fromList es
  <span class="kw">case</span> decEq (balance entries) <span class="dt">Zero</span> <span class="kw">of</span>
    (<span class="dt">Yes</span> prf) <span class="ot">=&gt;</span> pure <span class="fu">$</span> <span class="dt">MkEntries</span> entries
    (<span class="dt">No</span>  <span class="fu">_</span>)   <span class="ot">=&gt;</span> fail <span class="st">&quot;Entries are not balanced, total debits minus total credits should be 0&quot;</span></code></pre></div>
<p>In other words, there is no way<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> to build an invalid value and the Idris type system guarantees our <em>core model</em> will stay consistent <em>at compile time</em>. Applying a <em>Ports and adapters</em> or <em>Hexagonal Architecture</em> strategy leaves no room for introducing errors in our core model, completely alleviating the need to have such validation concerns (eg. checking values range, lengths, validate data…) leak into the model’s code.</p>
<h2 id="evaluation">Evaluation</h2>
<p>I was pretty happy with myself, patting me in the back for having succeeded in modelling double-entry bookkeeping in a nice simple type-safe model. Then I realised that <em>implementing</em> <code>Monoid Balance</code> was the first step, I still needed to <em>prove</em> the <a href="https://en.wikibooks.org/wiki/Haskell/Monoids#Monoid_laws">monoid laws</a> hold for my type and <code>&lt;+&gt;</code> operation. This is when things started to go awry…</p>
<p>The proof for neutral element is short but already highlights the main issue:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">rightNeutralBalance</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Balance</span>) <span class="ot">-&gt;</span> (x <span class="fu">&lt;+&gt;</span> (<span class="dv">0</span>, <span class="dt">Cr</span>) <span class="fu">=</span> x)
rightNeutralBalance (n, <span class="dt">Cr</span>) <span class="fu">=</span> <span class="kw">rewrite</span> plusZeroRightNeutral n <span class="kw">in</span> <span class="dt">Refl</span>
rightNeutralBalance (<span class="dt">Z</span>, <span class="dt">Dr</span>) <span class="fu">=</span> believe_me <span class="st">&quot;special case for zero debit&quot;</span>
rightNeutralBalance (<span class="dt">S</span> n, <span class="dt">Dr</span>) <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>The problem is that there really are <em>two</em> neutral elements, a 0 debit and a 0 credit. I have chosen to consider the canonical neutral element to be <code>(0, Cr)</code> but that’s just a convention which comes bite me in the back when trying to prove things: I am forced to use the magic <code>believe_me</code> function to lure the typechecker in the <code>(0, Dr)</code> case.</p>
<p>Things get even worse when trying to prove associativity:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">associativeBalance</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Balance</span>) <span class="ot">-&gt;</span> (y <span class="ot">:</span> <span class="dt">Balance</span>) <span class="ot">-&gt;</span> (z <span class="ot">:</span> <span class="dt">Balance</span>) <span class="ot">-&gt;</span> (x <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;+&gt;</span> z)
associativeBalance (a, <span class="dt">Dr</span>) (b, <span class="dt">Dr</span>) (c, <span class="dt">Dr</span>) <span class="fu">=</span> <span class="kw">rewrite</span> plusAssociative a b c <span class="kw">in</span> <span class="dt">Refl</span>
associativeBalance (a, <span class="dt">Cr</span>) (b, <span class="dt">Cr</span>) (c, <span class="dt">Cr</span>) <span class="fu">=</span> <span class="kw">rewrite</span> plusAssociative a b c <span class="kw">in</span> <span class="dt">Refl</span>
associativeBalance (a, <span class="dt">Dr</span>) (b, <span class="dt">Cr</span>) (c, <span class="dt">Cr</span>) <span class="kw">with</span> (order {to<span class="fu">=</span><span class="dt">LTE</span>} a (plus b c))
  <span class="fu">|</span> (<span class="dt">Left</span> l) <span class="kw">with</span> (order {to<span class="fu">=</span><span class="dt">LTE</span>} a b)
    <span class="fu">|</span> (<span class="dt">Left</span> x) <span class="fu">=</span> <span class="kw">rewrite</span> minusPlusPlusMinus b c a <span class="kw">in</span> <span class="dt">Refl</span>
    <span class="fu">|</span> (<span class="dt">Right</span> r) <span class="kw">with</span> (order {to<span class="fu">=</span><span class="dt">LTE</span>} (a <span class="fu">-</span> b) c)
      <span class="fu">|</span> (<span class="dt">Left</span> x) <span class="fu">=</span> <span class="kw">rewrite</span> minusPlusMinusMinus b c a <span class="kw">in</span> <span class="dt">Refl</span>
      <span class="fu">|</span> (<span class="dt">Right</span> x) <span class="fu">=</span> <span class="ot">?hole_4</span></code></pre></div>
<p>What happens here is that I got caught in a maze of lemmas involving various combinations of plus and minus operations, which unvoidably would end in the need to prove that <code>Dr = Cr</code> which, obviously, would fail or need some magic axiom.</p>
<p>After much struggling with the typechecker and discussion on slack, I realised this proof was problematic because the underlying types were fatally flawed. As brillantly stated by Ohad Kammar:</p>
<blockquote>
<p>Since it’s going to be impossible to get Idris to recognise all false statements automatically, the best we can hope for is that proving false statements is going to get more and more difficult until the programmer gives up</p>
</blockquote>
<p>The types are wrong because I am conflating two concepts: The <em>Balance</em> resulting from aggregating one or more entries for some account(s), and the <em>Amount</em> of each entry, along with a direction (Debit or Credit). Although they both are integral values with a “sign”, they have different meaning in the domain and different behaviour: A <em>Balance</em> can be 0, whereas an entry’s Amount cannot.</p>
<p>Moreover, the structure of the <code>Balance</code> type is also wrong and some form of premature optimisation: Instead of having a proper data type to represent the concept along with the constraints it supports, I am trying to “abuse” existing types.</p>
<h1 id="take-2">Take 2</h1>
<p>So I went for a deep refactoring of my code to cleanly separate the concepts of an <code>Amount</code> and a <code>Balance</code> along with their proper constraints. This was also a good opportunity to start splitting my code in more manageables parts.</p>
<h2 id="amounts">Amounts</h2>
<p>An <code>Amount</code> is basically a non-zero <code>Nat</code>ural integer so let’s embed that property in our type’s constructor:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Amount</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MkAmount</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> { <span class="kw">auto</span> notZero <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">1</span> n } <span class="ot">-&gt;</span> <span class="dt">Amount</span></code></pre></div>
<p>We want our <code>Amount</code> to be straightforward to use so I’ve decided I would like to equip it with a <code>Num</code> implementation:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Num</span> <span class="dt">Amount</span> <span class="kw">where</span>
  (<span class="dt">MkAmount</span> n {notZero<span class="fu">=</span>nz}) <span class="fu">+</span> (<span class="dt">MkAmount</span> k {notZero<span class="fu">=</span>nz'}) <span class="fu">=</span>
    <span class="dt">MkAmount</span> (n <span class="fu">+</span> k) { notZero <span class="fu">=</span> plusRightIsLte nz }

  (<span class="dt">MkAmount</span> n {notZero<span class="fu">=</span>nz}) <span class="fu">*</span> (<span class="dt">MkAmount</span> k {notZero<span class="fu">=</span>nz'}) <span class="fu">=</span>
    <span class="dt">MkAmount</span> (n <span class="fu">*</span> k) { notZero <span class="fu">=</span> lteOneMult nz nz' }

  fromInteger <span class="fu">=</span> fromIntegerAmount</code></pre></div>
<p>Although the actual <em>code</em> for addition and multiplication is trivial and it is <em>obvious</em> that adding and multiplying non-zero integers yields non-zero integers, it was non-trivial (at least for me) to build the needed proofs. The addition case relies on a couple of properties from <a href="https://www.idris-lang.org/docs/current/prelude_doc/docs/Prelude.Nat.html">Nat</a> defined in Idris’ prelude, namely that adding a number to the right of a <code>LTE</code> comparison preserves it, and that <code>LTE</code> is transitive:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">plusRightIsLte</span> <span class="ot">:</span> <span class="dt">LTE</span> j k <span class="ot">-&gt;</span> <span class="dt">LTE</span> j (k <span class="fu">+</span> n)
plusRightIsLte x   {k} <span class="fu">=</span> lteTransitive x (lteAddRight k)</code></pre></div>
<p>The multiplication case is similar except that the standard prelude does not provide a <code>lteMultRight</code> proof so I need to build it myself. This proofs is of course slightly different from the addition case because we need the factor <code>k</code> to be non-zero:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">lteMultRight</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> { <span class="kw">auto</span> nz <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">1</span> k } <span class="ot">-&gt;</span> <span class="dt">LTE</span> n (mult n k)
lteMultRight <span class="dt">Z</span>               <span class="fu">=</span> <span class="dt">LTEZero</span>
lteMultRight n     {k <span class="fu">=</span> <span class="dt">Z</span>}   <span class="kw">impossible</span>
lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> <span class="dt">S</span> k} <span class="fu">=</span>
  <span class="kw">rewrite</span> plusCommutative k (j <span class="fu">*</span> <span class="dt">S</span> k)
  <span class="kw">in</span> <span class="dt">LTESucc</span> (plusRightIsLte <span class="fu">$</span> lteMultRight j {k <span class="fu">=</span> <span class="dt">S</span> k})</code></pre></div>
<p>This is done by induction on <code>n</code> while prooving the case <code>k = 0</code> is indeed <code>impossible</code>, and here is a detailed step-by-step implementation:</p>
<p>Start with the signature for the <em>proposition</em>. Note that we can already use that signature in our implementation of <code>Num Amount</code>, as an additional hypothesis we’ll need to prove for our implementation to satisfy the typechecker:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">lteMultRight</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> { <span class="kw">auto</span> nz <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">1</span> k } <span class="ot">-&gt;</span> <span class="dt">LTE</span> n (mult n k)</code></pre></div>
<p>Hitting <code>C-c C-s</code> in Emacs and then case-splitting (with <code>C-c C-c</code> on <code>n</code> gives us the two base cases:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">lteMultRight</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> { <span class="kw">auto</span> nz <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">1</span> k } <span class="ot">-&gt;</span> <span class="dt">LTE</span> n (mult n k)
lteMultRight <span class="dt">Z</span> <span class="fu">=</span> <span class="ot">?lteMultRight_rhs_1</span>
lteMultRight (<span class="dt">S</span> j) <span class="fu">=</span> <span class="ot">?lteMultRight_rhs_2</span></code></pre></div>
<p>The first case is directly solvable by hitting <code>C-c C-a</code> on the provided hole, while we need to bring in scope the (implicit) <code>k</code> and case-split on it for the second case:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">lteMultRight <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">LTEZero</span>
lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> <span class="dt">Z</span>} <span class="fu">=</span> <span class="ot">?lteMultRight_rhs_1</span>
lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span> <span class="ot">?lteMultRight_rhs_3</span></code></pre></div>
<p>The second case is clearly <code>impossible</code> yet the typechecker fails to infer it automatically so we have to fill it by hand. This leaves us with the following hole to fill:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"> `<span class="co">--                                     k : Nat</span>
                                         <span class="fu">j</span> <span class="ot">:</span> <span class="dt">Nat</span>
                                        <span class="fu">nz</span> <span class="ot">:</span> <span class="dt">LTE</span> (fromInteger <span class="dv">1</span>) (<span class="dt">S</span> k)
     <span class="co">------------------------------------------------------------------------------</span>
      <span class="dt">Accounting</span><span class="fu">.</span><span class="dt">Amount</span><span class="fu">.</span>lteMultRight_rhs_3 <span class="ot">:</span> <span class="dt">LTE</span> (<span class="dt">S</span> j) (<span class="dt">S</span> (plus k (mult j (<span class="dt">S</span> k))))</code></pre></div>
<p>This type looks like something we can recurse over inductively because we know that:</p>
<pre><code>λΠ&gt; :t LTESucc
LTESucc : LTE left right -&gt; LTE (S left) (S right)</code></pre>
<p>So peeling one layer</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span>
  <span class="dt">LTESucc</span> <span class="ot">?hole</span></code></pre></div>
<p>and looking for the type of the hole we have</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"> `<span class="co">--                       k : Nat</span>
                           <span class="fu">j</span> <span class="ot">:</span> <span class="dt">Nat</span>
                          <span class="fu">nz</span> <span class="ot">:</span> <span class="dt">LTE</span> (fromInteger <span class="dv">1</span>) (<span class="dt">S</span> k)
     <span class="co">--------------------------------------------------------</span>
      <span class="dt">Accounting</span><span class="fu">.</span><span class="dt">Amount</span><span class="fu">.</span>hole <span class="ot">:</span> <span class="dt">LTE</span> j (plus k (mult j (<span class="dt">S</span> k)))</code></pre></div>
<p>gives us some more information. We can call <code>lteMultRight</code> inductively on <code>j</code> (which is reducing <code>n</code>) and see what’s needed:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span>
  <span class="dt">LTESucc</span> (<span class="ot">?hole</span> <span class="fu">$</span> lteMultRight j {k <span class="fu">=</span> <span class="dt">S</span> k})</code></pre></div>
<p>which gives us the <code>hole</code></p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">  <span class="fu">k</span> <span class="ot">:</span> <span class="dt">Nat</span>
  <span class="fu">j</span> <span class="ot">:</span> <span class="dt">Nat</span>
  <span class="fu">nz</span> <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">1</span> (<span class="dt">S</span> k)
<span class="co">--------------------------------------</span>
<span class="dt">Accounting</span><span class="fu">.</span><span class="dt">Amount</span><span class="fu">.</span>hole <span class="ot">:</span> <span class="dt">LTE</span> j (mult j (<span class="dt">S</span> k)) <span class="ot">-&gt;</span> <span class="dt">LTE</span> j (plus k (mult j (<span class="dt">S</span> k)))</code></pre></div>
<p>We now notice that the type of <code>hole</code> looks like the type of our <code>plusRightIsLte</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">plusRightIsLte</span> <span class="ot">:</span> <span class="dt">LTE</span> j n         <span class="ot">-&gt;</span> <span class="dt">LTE</span> j (n <span class="fu">+</span> k)
<span class="fu">hole</span>           <span class="ot">:</span> <span class="dt">LTE</span> j (j <span class="fu">*</span> <span class="dt">S</span> k) <span class="ot">-&gt;</span> <span class="dt">LTE</span> j (k <span class="fu">+</span> (j <span class="fu">*</span> <span class="dt">S</span> k))</code></pre></div>
<p>but with <code>n = j * S k</code> and the order of arguments in the addition on the right reversed. We can pull in the fact that addition is commutative:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span>
  <span class="kw">rewrite</span> plusCommutative k (j <span class="fu">*</span> <span class="dt">S</span> k)
  <span class="kw">in</span> <span class="dt">LTESucc</span> (<span class="ot">?hole</span> <span class="fu">$</span> lteMultRight j {k <span class="fu">=</span> <span class="dt">S</span> k})</code></pre></div>
<p>and now our <code>hole</code> has the right type:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">      <span class="dt">Accounting</span><span class="fu">.</span><span class="dt">Amount</span><span class="fu">.</span>hole <span class="ot">:</span> <span class="dt">LTE</span> j (j <span class="fu">*</span> <span class="dt">S</span> k) <span class="ot">-&gt;</span> <span class="dt">LTE</span> j ((j <span class="fu">*</span> <span class="dt">S</span> k)  <span class="fu">+</span> k)</code></pre></div>
<p>which allows us to conclude our proof:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">lteMultRight (<span class="dt">S</span> j) {k <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span>
  <span class="kw">rewrite</span> plusCommutative k (j <span class="fu">*</span> <span class="dt">S</span> k)
  <span class="kw">in</span> <span class="dt">LTESucc</span> (plusRightIsLte <span class="fu">$</span> lteMultRight j {k <span class="fu">=</span> <span class="dt">S</span> k})</code></pre></div>
<p>The real process was much more hectic and I needed quite a lot of help from slack’s people!</p>
<h2 id="balance">Balance</h2>
<p>We can now turn our attention to the <code>Balance</code> type and provide an implementation that takes into account the possibility for a balance to be <em>null</em> while preserving the chances to make our <code>Balance</code> type a proper monoid:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Balance</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">Zero</span> <span class="ot">:</span> <span class="dt">Balance</span>
  <span class="dt">Bal</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Amount</span>) <span class="ot">-&gt;</span> (d <span class="ot">:</span> <span class="dt">Direction</span>) <span class="ot">-&gt;</span> <span class="dt">Balance</span></code></pre></div>
<p>The key insight here is to introduce a special constructor to denote 0 which will remove the need to do “magical” things when 2 <code>Balance</code> gets to compensate each other depending on the ordering of the operands. The definitions for the various algebraic structure our <code>Balance</code> is supposed to implement (semigroup, monoid and group) are simple once we introduce the <code>compensate</code> operation relating <code>Amount</code>s and <code>Direction</code>s to yield a <code>Balance</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">compensate</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Amount</span>) <span class="ot">-&gt;</span> (d <span class="ot">:</span> <span class="dt">Direction</span>)
          <span class="ot">-&gt;</span> (n' <span class="ot">:</span> <span class="dt">Amount</span>) <span class="ot">-&gt;</span> (d' <span class="ot">:</span> <span class="dt">Direction</span>)
          <span class="ot">-&gt;</span> { <span class="kw">auto</span> notEqDir <span class="ot">:</span> <span class="dt">Not</span> (d <span class="fu">=</span> d') }
          <span class="ot">-&gt;</span> <span class="dt">Balance</span>
compensate (<span class="dt">MkAmount</span> n) d (<span class="dt">MkAmount</span> n') d' <span class="kw">with</span> (decEq n n')
    <span class="fu">|</span> (<span class="dt">Yes</span> prf) <span class="fu">=</span> <span class="dt">Zero</span>
    <span class="fu">|</span> (<span class="dt">No</span> contra) <span class="kw">with</span> (order {to<span class="fu">=</span><span class="dt">LTE</span>} n n')
      <span class="fu">|</span> (<span class="dt">Left</span> l)  <span class="fu">=</span> <span class="dt">Bal</span> (<span class="dt">MkAmount</span> (n' <span class="fu">-</span> n)
                        { notZero <span class="fu">=</span> notEqualMinusGTOne n n' l contra }) d'
      <span class="fu">|</span> (<span class="dt">Right</span> r) <span class="fu">=</span> <span class="dt">Bal</span> (<span class="dt">MkAmount</span> (n <span class="fu">-</span> n')
                        { notZero <span class="fu">=</span> notEqualMinusGTOne n' n r (notEqReflexive contra) }) d</code></pre></div>
<p>This definition is however made more complex than we’d hoped because: 1. When substracting 2 <code>Nat</code>ural numbers, we need to prove the first number is greater than or equal to the second one, which entails the need to call <code>order</code> here to case-split on the order of the 2 numbers with the relevant proof, 2. We also need to ensure the difference is still greater than or equal to 1 in order to build an <code>Amount</code>.</p>
<p>This is a tribute to the fact our <code>Amount</code> type is “complex”, eg. its constructor is not only a <em>structure</em> to aggregate some other datatypes but also carries with it some <em>proofs</em> which need to be maintained at all time. This will come bite us again later on…</p>
<h2 id="refactoring">Refactoring</h2>
<p>Changing our 2 core types’ definition ripples through our system but without entailing any deep changes in our top-level types. The structure and the properties of our <code>Entry</code>, <code>Transaction</code>, <code>Entries</code> and <code>BookOfAccounts</code> types stay mostly the same except for the fact we don’t use <code>Balance</code> for defining an <code>Entry</code> but separate the <code>Amount</code> and the <code>Direction</code>. We only have to fix the compiler’s errors one at a time and end-up with pretty much the same code than we had before.</p>
<p>The introduction of <code>Amount</code> forces us however to make the numbers explicit in our sample entries. Although <code>Amount</code> is a <code>Num</code>ber and the compiler automatically introduces a conversion <code>fromInteger</code> when we use a literal in place of an <code>Amount</code>, writing</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">valid1</span> <span class="ot">:</span> balance [ <span class="dt">MkEntry</span> <span class="dv">100</span> <span class="dt">Dr</span> <span class="dt">Bank</span>,
                   <span class="dt">MkEntry</span> <span class="dv">100</span> <span class="dt">Cr</span> <span class="dt">Capital</span> ] <span class="fu">=</span> <span class="dt">Zero</span>
valid1 <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>yields the following typechecker error:</p>
<pre><code>             Type mismatch between
                     Zero
             and
                     compensate (fromIntegerAmount 100) Dr (fromIntegerAmount 100) Cr</code></pre>
<p>because the typechecker cannot see “past” <code>fromIntegerAmount</code>. We need to either explicitly call <code>MkAmount</code> or turn on <code>public export</code> visibility on <code>fromIntegerAmount</code> to allow the typechecker to reduce expressions usinge the definition of the function.</p>
<h2 id="evaluation-1">Evaluation</h2>
<p>The situation is definitely better than with our first model: We have a clear separation of two key concepts in our system and have strengthened our understanding of the domain and the relationship between the domain and the code by baking more properties.</p>
<p>Turns out it’s not all bright and shinny, which becomes apparent when we try (again) to prove the <code>Group Balance</code> properties. I won’t go into the tedious details in this already long post but this ended up being a long, interesting but painful journey in the realm of proofs writing. Interested reader is referred to the <a href="https://github.com/abailly/xxi-century-typed/blob/master/idris/src/Accounting/Proofs.idr">Proofs.idr</a> file which contains the current (unfinished) state of the proofs of neutral element, inverse and associativity of <code>Balance</code> with <code>&lt;+&gt;</code> operation.</p>
<p>I gave up trying to prove associativity at some point, when it became clear the proof would be a long and tedious enumeration of all possible cases depending on the respective ordering of the <code>Balance</code>s and the values of their <code>direction</code>. This is caused by the fact the definition of <code>&lt;+&gt;</code> involves a case-split on the <code>direction</code>s and then uses <code>compensate</code> which itself involves 2 case-splitting: on the the equality of the values, and on their relative ordering. The Idris typechecker works by replacing each function call by its definition and trying to reduce the resulting expression to some ground types. This means that when one wants to provide a proof that <code>(a &lt;+&gt; b) &lt;+&gt; c = a &lt;+&gt; (b &lt;+&gt; c)</code>, the applications of <code>&lt;+&gt;</code> are only reduced if the typechecker can follow the various branches in <code>&lt;+&gt;</code> definition to conclude. This can only happen if we provide the relevant proofs which basically means the structure of our proof necessarily follows from various <em>paths</em> leading to a conclusion in our function’s implementation.</p>
<h1 id="conclusion-and-takeaways">Conclusion and Takeaways</h1>
<p>I have not yet undertaken <em>Take 3</em> but it’s pretty clear I am not there yet: The fact the proof for associativity of <code>Balance</code> is still daunting and painful is certainly a sign the involved types are more complex than they should be and need some more refactoring.</p>
<p>There are a couple of other options that would be worth exploring: * The embedding of the <code>notZero</code> proof does not seem like a good idea as it brings more proof obligations in scope at each use of an <code>Amount</code>. A better solution could be to have <code>Amount</code> use directly <code>Nat</code> but consider it to represent it’s successor, and then provide smart constructor and operations to manipulate those numbers while preserving this internal property, * There exists a <a href="https://github.com/idris-lang/Idris-dev/blob/master/libs/contrib/Data/ZZ.idr">ZZ</a> module to represent <em>relative</em> integers. I could either get some inspiration from it or use it directly for <code>Amount</code>s and to hold a <code>Balance</code>, with some encoding to extract the direction (debit or credit) from the sign of the number, * Rather than trying to make <code>Balance</code> into a <code>Monoid</code>/<code>Group</code>, I could define a <code>Vect n Entry</code> to be a <code>Monoid</code> action <em>on</em> a <code>Balance</code>, eg. provide a specialised operation that applies an <code>Entry</code> on a <code>Balance</code> to give another <code>Balance</code>.</p>
<p>I am currently leaning towards exploring a combination of option 2 (use <code>ZZ</code> to contain an <code>Entry</code>’s amount and drop <code>Amount</code>) and option 3 (keep a separate <code>Balance</code> type but only use it in conjuction with <code>Entry</code>) as it seems to be both simpler than the current solution yet still close to the domain.</p>
<p>All in all, this experience has confirmed my initial intuition about Idris and the relevance of dependently-typed languages in providing “better” business domain models, something which I have been convinced of since I discovered Idris thanks to Edwin Brady’s <a href="https://www.manning.com/books/type-driven-development-with-idris">book</a>. Working through some involved (for me) proofs was an eye opener on both how difficult this process can be, and how much insight in one’s design it can provide. Some key takeaways I would like to share are:</p>
<ul>
<li>“Proving” propositions by coding their implementation is really fun, and at the same time immensely frustrating: You see something that’s obvious, and you try to convince the typechecker this is indeed obvious armed with a bunch of functions, types and rewriting rules, and it sometimes does not align and you don’t know why…</li>
<li>Proving negative statements (eg. types of the form <code>foo -&gt; Void</code>) is often, somewhat unsurprisingly, harder and less intuitive than proving positive statements</li>
<li>Thanks to the help provided by various people on slack, I had some <em>Ah-ah</em> moments on the inner workings of the typechecker and gathered some more insights on how to write proofs:</li>
<li>For a function call involved in a proof to be reduced, it needs to which case to chose which implies one need to either provide explicitly pattern-matching on arguments or <code>with</code> clauses (which really act like “local” arguments),</li>
<li>The order of case-splitting on arguments matters and can make a proof more or less complicated,</li>
<li>It’s generally easier to prove general statements and then use that in a specialised way, than the converse,</li>
<li><em>Implicit</em> values are not rewritten by <code>rewrite ... in ...</code> statements, so they need to be provided in some way in the context</li>
<li>As already stated, it’s better to not have <em>implicit</em> proofs be part of one’s types definitions: Only export the type itself and provide smart constructors when needed.</li>
<li>Leveraging the REPL and the interactions it permits is very important as it permits one to isolate the problems to solve, step-by-step, until all is left are simple lemmas or possibly axioms,</li>
<li>Relating domain-level concepts to more abstract mathematical or computer-related concepts can be a source of insights on the domain itself, for example relating a <code>Balance</code> to <code>Monoid</code> or <code>Group</code>. And trying to prove the relevant properties gives more insights on the <em>representation</em> used and whether or not it suits our purpose.</li>
</ul>
<p>This last point in particular is interesting as it provides a way to start a dialog between the <em>domain</em> and the <em>code</em> that is not one-way. We often develop software considering the “business domain” <em>ex abstracto</em>, as if the fact we were designing a <em>software system</em> for that domain was irrelevant. But this is not true, the fact it <em>runs on software</em> changes the domain itself hence it’s perfectly legitimate we can gather insights about the domain from the code implementing it. In the case of <em>accounting</em> this is pretty obvious as we are manipulating numbers and it’s a well-studied domain, but I think most if not all domains would strongly benefit from such dialog, transforming as hodge-podge of ad-hoc rules into something simpler, more regular and probably more efficient.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It’s interesting to note the original sentence seems to imply capital and equity are one and same thing, which is not true.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Short of cheating using something like <a href="https://www.idris-lang.org/docs/current/prelude_doc/docs/%5Bbuiltins%5D.html#believe_me">believe_me</a> of course that will <em>subvert the typechecker</em>.<a href="#fnref2">↩</a></p></li>
</ol>
</div>


<div id="disqus_thread"></div>
<script>
  (function() {  // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
  
    s.src = '//arnaudsblog.disqus.com/embed.js';
  
    s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



    </div>
    <footer>
       <a href="https://fr.linkedin.com/in/arnaudbailly"> <img src="/images/linkedin.png" width="28" /></a>  <a href="https://twitter.com/dr_c0d3"> <img width="32" src="/images/twitter.png" /></a>  <a href="/atom.xml"><img src="/images/feed-icon.svg" width="24px" /></a>  <a href="http://jaspervdj.be/hakyll"><img src="/images/lambda.png" width="24px" /></a>
    </footer>
    
  </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42631907-2', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
