<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <title>Arnaud Bailly - Life Beyond Relational Database in Haskell -
The case for Event Sourcing</title>
  <meta name="description" content="Crafting code since 1994">
  <meta name="author" content="Arnaud Bailly">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Lato">
  <link rel="stylesheet" type="text/css" href="/css/style.css?v=3">
  <link rel="stylesheet" type="text/css" href="/css/default.css">
  <link rel="stylesheet" type="text/css" href="/css/syntax.css">
  <script src="/js/modernizr-2.0.6.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div id="container">
    <header>
      <div id="company-title">
        <a href="/"><img id="company-logo" src="/images/logo.png" width="259" height="75" title="igitur.io" /></a>
      </div>
      <div>
        <nav class="clearfix">
        <ul id="menu">
          <li>
          <a href="http://drcode.io">Dr.Code</a>
          </li>
          <li>
          <a href="/about.html">About</a>
          </li>
        </ul>
        </nav>
      </div>
    </header>
    <div id="main" role="main">
<h1>Life Beyond Relational Database in Haskell - The case for Event
Sourcing</h1>
<div class="info">Posted on 2016-05-12</div>

<p>This post contains the code I demonstrated as part of my talk at <a
href="http://ncrafts.io">nCrafts</a>. This work is based on the
following references (stepping on the shoulders of giants, as
always…):</p>
<ul>
<li><a
href="http://okmij.org/ftp/Haskell/extensible/exteff.pdf">Extensible
effects paper</a>: Extensible effects theory and practice in
Haskell</li>
<li><a href="https://github.com/atnos-org/eff-cats">eff-cats</a>: Same
in Scala</li>
<li><a
href="http://www.cse.chalmers.se/~rjmh/Papers/QuickCheckST.ps">Testing
monadic code with QuickCheck</a></li>
<li><a href="http://abailly.github.io/posts/cm-arch-design.html">Blog
post</a> about the architecture implemented at Capital Match</li>
<li>Work-in-progress <a
href="https://github.com/abailly/hevents">Haskell library</a> to
simplify developing event sourced systems</li>
<li>Original <a href="http://shaffner.us/cs/papers/tarpit.pdf">Out of
the Tar Pit</a> paper</li>
</ul>
<h1 id="imports-stuff-to-make-the-compiler-happy">Imports, stuff to make
the compiler happy</h1>
<p>We first add the usual <code>LANGUAGE</code> extension incantations…
Note they should probably go in to the <code>.cabal</code> file.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds             #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances     #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables   #-}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators         #-}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Hevents.Eff.Demo</span> <span class="kw">where</span></span></code></pre></div>
<p>Then a whole bunch of imports… I never managed to choose a definite
course of action on whether to import full module, import qualified,
import only selected symbols. Seems to me this is pretty much a
team-level convention.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Category</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Concurrent.Async</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Concurrent.STM</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Eff</span>                <span class="kw">as</span> <span class="dt">E</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Eff.Exception</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Eff.Lift</span>           <span class="kw">as</span> <span class="dt">E</span> <span class="kw">hiding</span> (lift)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Exception</span>          (finally)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Except</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.State</span>        <span class="kw">as</span> <span class="dt">ST</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Trans.Either</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Builder</span>    <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Either</span>                (rights)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Proxy</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Serialize</span>             (<span class="dt">Serialize</span>, get, put)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Typeable</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Void</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Hevents.Eff</span>                <span class="kw">as</span> <span class="dt">W</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Prelude</span>                    <span class="kw">hiding</span> (init, (.))</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Servant</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Servant.Client</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">System.Environment</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Test.Hspec</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Test.QuickCheck</span>            <span class="kw">as</span> <span class="dt">Q</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Test.QuickCheck.Monadic</span>    <span class="kw">as</span> <span class="dt">Q</span></span></code></pre></div>
<h1 id="the-business-domain">The “Business Domain”</h1>
<p>We want to implement an event-sourced service that will allow us to
manipulate a simple integer <em>counter</em>:</p>
<ul>
<li>Our counter changes when some value is <em>added</em> to it,</li>
<li>A value is added when a command is issued that <em>increments</em>
the counter,</li>
<li>We also want to modify the counter when a <em>decrement</em> command
is issued, which means a <em>negative</em> value will be <em>added</em>
to the counter,</li>
<li>We want our counter to be <em>bounded</em>: It shall never go below
0 or beyond 100,</li>
<li>And its initial value will be 0.</li>
</ul>
<h1 id="lets-start-writing-a-test">Let’s start writing a test…</h1>
<p>We’ll first write some property describing the behaviour of our model
for a single command. We expect that an <code>Increment</code> command
shall set an <code>init</code>ialized counter to the same value than the
command, and that a <code>Decrement</code> command will decrease the
value of a counter. Note here we anticipate a bit on bounds requirement
checking by setting the counter to some value which is greater than any
<code>Decrement</code> command we are supposed to issue.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_shouldApplySingleCommandRespectingBounds ::</span> <span class="dt">Command</span> <span class="dt">Counter</span><span class="op">*&gt;</span> <span class="dt">Bool</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>prop_shouldApplySingleCommandRespectingBounds c<span class="op">@</span>(<span class="dt">Increment</span> n) <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">OK</span> result <span class="ot">=</span> <span class="fu">init</span> <span class="ot">`act`</span> c</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span>  <span class="fu">init</span> <span class="ot">`apply`</span> result <span class="op">==</span> <span class="dt">Counter</span> n</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>prop_shouldApplySingleCommandRespectingBounds c<span class="op">@</span>(<span class="dt">Decrement</span> n) <span class="ot">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bounderCounter <span class="ot">=</span> <span class="dt">Counter</span> singleCommandUpperBound</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">OK</span> result <span class="ot">=</span> bounderCounter <span class="ot">`act`</span> c</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span>  bounderCounter <span class="ot">`apply`</span> result <span class="op">==</span> <span class="dt">Counter</span> (singleCommandUpperBound <span class="op">-</span> n)</span></code></pre></div>
<p>This property requires some way to generate <code>Arbitrary</code>
instances of our commands, which is straightforward:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> (<span class="dt">Command</span> <span class="dt">Counter</span>) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> oneof [ <span class="dt">Increment</span> <span class="op">&lt;$&gt;</span> singleCommandValue</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                    , <span class="dt">Decrement</span> <span class="op">&lt;$&gt;</span> singleCommandValue</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                    ]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        singleCommandValue <span class="ot">=</span> choose (<span class="dv">0</span>,singleCommandUpperBound)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">singleCommandUpperBound ::</span> <span class="dt">Int</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>singleCommandUpperBound <span class="ot">=</span> <span class="dv">20</span></span></code></pre></div>
<p>Another useful property we want to define that our counter respects
its bounds, no matter which sequence of events we send to it:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_shouldNotApplyCommandsOverBounds ::</span> [ <span class="dt">Command</span> <span class="dt">Counter</span> ] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>prop_shouldNotApplyCommandsOverBounds commands <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> finalCounter <span class="ot">=</span> ST.execState (<span class="fu">mapM</span> updateModel commands) <span class="fu">init</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  isWithinBounds finalCounter</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">isWithinBounds ::</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>isWithinBounds (<span class="dt">Counter</span> value) <span class="ot">=</span> value <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;=</span> <span class="dv">100</span></span></code></pre></div>
<p>And of course we need some implementation of our
<code>Command</code>s and <code>Counter</code>. The latter is pretty
much a simple wrapping of <code>Int</code> but to define the former we
need our <code>Counter</code> type to be an instance of <a
href="https://github.com/abailly/hevents/blob/master/src/Hevents/Eff/Model.lhs">Model</a>
typeclass, which defines the basic structure of an event-sourced
component (or aggregate).</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Counter</span> <span class="ot">=</span> <span class="dt">Counter</span> {<span class="ot"> counter ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Model</span> <span class="dt">Counter</span> <span class="kw">where</span></span></code></pre></div>
<p>We define the “component” types of our model: Commands, events and
errors which here are very simple.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">Counter</span> <span class="ot">=</span> <span class="dt">Increment</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                       <span class="op">|</span> <span class="dt">Decrement</span> <span class="dt">Int</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Event</span> <span class="dt">Counter</span> <span class="ot">=</span> <span class="dt">Added</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Error</span> <span class="dt">Counter</span> <span class="ot">=</span> <span class="dt">OutOfBounds</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</span></code></pre></div>
<p>Then comes our initial value…</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">init</span> <span class="ot">=</span> <span class="dt">Counter</span> <span class="dv">0</span></span></code></pre></div>
<p><code>act</code> computes the effect of applying a command to current
state of our counter…</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Counter</span> k <span class="ot">`act`</span> <span class="dt">Increment</span> n <span class="ot">=</span> <span class="kw">if</span> k <span class="op">+</span> n <span class="op">&lt;=</span> <span class="dv">100</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">then</span> <span class="dt">OK</span> <span class="op">$</span> <span class="dt">Added</span> n</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">else</span> <span class="dt">KO</span> <span class="dt">OutOfBounds</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Counter</span> k <span class="ot">`act`</span> <span class="dt">Decrement</span> n <span class="ot">=</span> <span class="kw">if</span> k <span class="op">-</span> n <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">then</span> <span class="dt">OK</span> <span class="op">$</span> <span class="dt">Added</span> (<span class="op">-</span>n)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">else</span> <span class="dt">KO</span> <span class="dt">OutOfBounds</span></span></code></pre></div>
<p>Then <code>apply</code> actually “updates” (or more precisely, create
a new updated instance of) the counter by applying the value to add.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Counter</span> k <span class="ot">`apply`</span> <span class="dt">Added</span> n <span class="ot">=</span> <span class="dt">Counter</span> <span class="op">$</span> k <span class="op">+</span> n</span></code></pre></div>
<p>When we check the behaviour of applying a sequence of
<code>Command</code>s to our counter, we make use of a library function
which runs in the <code>State</code> monad and allow us to “fold” the
application of a sequence of commands to a <code>Counter</code>:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateModel ::</span> (<span class="dt">Model</span> a) <span class="ot">=&gt;</span> <span class="dt">Command</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> a (<span class="dt">Result</span> a)</span></code></pre></div>
<h1 id="exposing-services-built-on-our-model">Exposing services built on
our model</h1>
<p>As always, we start with the testing part but this time we expect our
tests to have side effects and model interactions of the outside world
with our system’s fragment. We shall start with very simple modelling of
client’s behaviour:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CounterAction</span> <span class="ot">=</span> <span class="dt">GetCounter</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="dt">IncCounter</span> <span class="dt">Int</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="dt">DecCounter</span> <span class="dt">Int</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>In order to generate samples for our actions we assume some frequency
distribution, giving more weight to actions that get state than to
actions that update it.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">CounterAction</span> <span class="kw">where</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> frequency [ (<span class="dv">3</span>, <span class="fu">return</span> <span class="dt">GetCounter</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                        , (<span class="dv">2</span>, <span class="dt">IncCounter</span> <span class="op">&lt;$&gt;</span> choose (<span class="dv">0</span>,<span class="dv">10</span>))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                        , (<span class="dv">1</span>, <span class="dt">DecCounter</span> <span class="op">&lt;$&gt;</span> choose (<span class="dv">0</span>,<span class="dv">10</span>))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                        ]</span></code></pre></div>
<p>Then we use monadic QuickCheck to run an <code>arbitrary</code>
sequence of user actions on an “effectful” model which is initialised
with some state holder and a storage backend.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_servicesRespectCounterBounds ::</span> [ <span class="dt">CounterAction</span> ] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>prop_servicesRespectCounterBounds actions <span class="ot">=</span> Q.monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  results <span class="ot">&lt;-</span> Q.run <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    (model, storage) <span class="ot">&lt;-</span> prepareContext</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM</span> (effect storage model <span class="op">.</span> interpret) actions</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  assert <span class="op">$</span> <span class="fu">all</span> isWithinBounds (rights results)</span></code></pre></div>
<p>This test might be considered to be a little weak, and we could
probably enhance it with testing error conditions. That’s something
definitely worth doing for production code, however for the sake of
simplicity we will not add more tests here.</p>
<p>Prparation step is simple but deserve some explanations:</p>
<ul>
<li>We create a <code>Counter</code> with some initial value and wrap it
in a <em>transactional variable</em> because our underlying
<code>State</code> effects works within the <code>STM</code> monad. This
is so in order to ensure proper atomicity of commands on the model in
face of concurrent access,</li>
<li>We create a simple in-memory store, which is a STM-based bounded
queue.</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>prepareContext <span class="ot">=</span> (,)           <span class="op">&lt;$&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  newTVarIO (W.init<span class="ot"> ::</span> <span class="dt">Counter</span>) <span class="op">&lt;*&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  atomically W.makeMemoryStore</span></code></pre></div>
<p><code>effect</code> is actually a natural transformation that
composes all the small little effects we need in our sample and “lift”
them in the <code>IO</code> monad. Note the <code>Eff</code> type which
exposes explicitly all the effects our code is allowed to make thus
constraining its behaviour to a limited subset of possible interactions
with outside world. The <code>ServantErr</code> type is the type of
<em>exceptions</em> we can “throw” using <code>Exc</code> effect: This
anticipates on the needs of the REST API we shall expose later on.
Actually it could have been any kind of <code>Exception</code> instance
but once again, this makes things simpler and removes a layer of
transformation from custom exceptions to Servant errors, something we
would probably want to do in production code.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EventSourced</span> s e a <span class="ot">=</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">E.Eff</span> (<span class="dt">State</span> s <span class="op">E.:&gt;</span> <span class="dt">Store</span> <span class="op">E.:&gt;</span> <span class="dt">Exc</span> e <span class="op">E.:&gt;</span> <span class="dt">Lift</span> <span class="dt">STM</span> <span class="op">E.:&gt;</span> <span class="dt">Void</span>) a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">effect ::</span> (<span class="dt">Typeable</span> m, <span class="dt">Typeable</span> e, <span class="dt">Storage</span> <span class="dt">STM</span> s, <span class="dt">Registrar</span> <span class="dt">STM</span> m reg)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>         <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> reg</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">E.Eff</span> (<span class="dt">EventSourced</span> <span class="dt">Counter</span> <span class="dt">ServantErr</span>) a</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> e a)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>effect s m <span class="ot">=</span> atomically <span class="op">.</span> runSync <span class="op">.</span> runExc <span class="op">.</span> W.runStore s <span class="op">.</span>  W.runState m</span></code></pre></div>
<p>The definition of our services is pretty straightforward:</p>
<ul>
<li><code>getCounter</code> simply return the state of the counter,</li>
<li><code>increment</code> and <code>decrement</code> both send the
corresponding commands and store the resulting event, returning the
content of the counter.</li>
</ul>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CounterService</span> a <span class="ot">=</span> <span class="dt">EventSourced</span> <span class="dt">Counter</span> <span class="dt">ServantErr</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">getCounter ::</span> <span class="dt">CounterService</span> <span class="dt">Int</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>getCounter <span class="ot">=</span> counter <span class="op">&lt;$&gt;</span> getState</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="ot">increment ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CounterService</span> <span class="dt">Int</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>increment n <span class="ot">=</span> applyCommand (<span class="dt">Increment</span> n) <span class="op">&gt;&gt;=</span> storeEvent</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="ot">decrement ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CounterService</span> <span class="dt">Int</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>decrement n <span class="ot">=</span> applyCommand (<span class="dt">Decrement</span> n) <span class="op">&gt;&gt;=</span> storeEvent</span></code></pre></div>
<p>The <code>storeEvent</code> function is where most of the grunt work
happens and notably where we do error handling:</p>
<ul>
<li>We first try to <code>store</code> the produced <code>Event
Counter</code>, and if this succeeds we return the state of the counter.
If this fails, we convert the error in a <code>500</code> error, passing
some hopefully useful message,</li>
<li>If the input is an <code>Error Counter</code> we simply rethrow the
converted error as a <code>400</code> error, all errors produced by
commands represent precondition violations of the model’s
specification.</li>
</ul>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">storeEvent ::</span> <span class="dt">Either</span> (<span class="dt">Error</span> <span class="dt">Counter</span>) (<span class="dt">Event</span> <span class="dt">Counter</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">CounterService</span> <span class="dt">Int</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>storeEvent (<span class="dt">Left</span> e)  <span class="ot">=</span> throwExc <span class="op">$</span> fromModelError e</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>storeEvent (<span class="dt">Right</span> e) <span class="ot">=</span> store e <span class="op">&gt;&gt;=</span> <span class="fu">either</span> (throwExc <span class="op">.</span> fromDBError) (<span class="fu">const</span> <span class="op">$</span> counter <span class="op">&lt;$&gt;</span> getState)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    fromModelError e <span class="ot">=</span> err400 { errBody <span class="ot">=</span> makeBody <span class="op">$</span> <span class="st">&quot;Invalid command &quot;</span> <span class="op">++</span> <span class="fu">show</span> e }</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    fromDBError    e <span class="ot">=</span> err500 { errBody <span class="ot">=</span> makeBody <span class="op">$</span> <span class="st">&quot;DB Error &quot;</span> <span class="op">++</span> <span class="fu">show</span> e }</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    makeBody         <span class="ot">=</span> BS.toLazyByteString <span class="op">.</span> BS.stringUtf8</span></code></pre></div>
<p>Note that because of the <code>Store</code> effect we need to be able
to <em>serialize</em> our events:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Serialize</span> (<span class="dt">Event</span> <span class="dt">Counter</span>) <span class="kw">where</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  put (<span class="dt">Added</span> i) <span class="ot">=</span> put i</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  get           <span class="ot">=</span> <span class="dt">Added</span> <span class="op">&lt;$&gt;</span> get</span></code></pre></div>
<p>The last missing piece is the <code>interpret</code> function which
turns our QuickCheck generated actions into actual effectful actions to
be run against our system.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">GetCounter</span>     <span class="ot">=</span> getCounter</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">IncCounter</span> n) <span class="ot">=</span> increment n</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">DecCounter</span> n) <span class="ot">=</span> decrement n</span></code></pre></div>
<h1 id="expose-our-counter-services-through-a-rest-api">Expose our
counter services through a REST API</h1>
<p>The last step of our Counter “microservice” is to expose it as a REST
interface. We will leverage the excellent work done on the <a
href="http://servant.github.io">Servant</a> and firstly define out API’s
type which is a simple exposition of the previously defined
services:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CounterApi</span> <span class="ot">=</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a> <span class="st">&quot;counter&quot;</span> <span class="op">:&gt;</span> (<span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>              <span class="op">:&lt;|&gt;</span> <span class="st">&quot;increment&quot;</span> <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;inc&quot;</span> <span class="dt">Int</span> <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>              <span class="op">:&lt;|&gt;</span> <span class="st">&quot;decrement&quot;</span> <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;dec&quot;</span> <span class="dt">Int</span> <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="ot">counterApi ::</span> <span class="dt">Proxy</span> <span class="dt">CounterApi</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>counterApi <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>Writing our test is pretty straightforward and mostly repeats the
previous test at the service level layer, the main difference being the
effectful services are run within an actual web server on some
predefined port. Note this is makes our test brittle and non
parallelizable: It would be better to let the server select a free port
and return it as part of its startup.</p>
<p>The only noteworthy part is that we can use our previously defined
<code>effect</code> “interpreter” natural transformation and wrap it
inside an <code>EitherT</code> transformer which is the type expected by
Servant.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_counterServerImplementsCounterApi ::</span> [ <span class="dt">CounterAction</span> ] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>prop_counterServerImplementsCounterApi actions <span class="ot">=</span> Q.monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  results <span class="ot">&lt;-</span> Q.run <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    (model, storage) <span class="ot">&lt;-</span> prepareContext</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    server <span class="ot">&lt;-</span> W.runWebServerErr <span class="dv">8082</span> counterApi</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>                  (<span class="dt">Nat</span> <span class="op">$</span> <span class="dt">EitherT</span> <span class="op">.</span> effect storage model) handler</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM</span> runClient actions <span class="ot">`finally`</span> cancel server</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  assert <span class="op">$</span> <span class="fu">all</span> isWithinBounds (rights results)</span></code></pre></div>
<p>The client-side services are obtained from a destructured assignment
using Servant’s <code>(:&lt;|&gt;)</code> operator which is overloaded
at the type and value level and then used to interpret user actions.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>counterState <span class="op">:&lt;|&gt;</span> incCounter <span class="op">:&lt;|&gt;</span> decCounter <span class="ot">=</span> client counterApi (<span class="dt">BaseUrl</span> <span class="dt">Http</span> <span class="st">&quot;localhost&quot;</span> <span class="dv">8082</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>runClient <span class="dt">GetCounter</span>     <span class="ot">=</span> runEitherT <span class="op">$</span> counterState</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>runClient (<span class="dt">IncCounter</span> n) <span class="ot">=</span> runEitherT <span class="op">$</span> incCounter n</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>runClient (<span class="dt">DecCounter</span> n) <span class="ot">=</span> runEitherT <span class="op">$</span> decCounter n</span></code></pre></div>
<p>It is also noteworthy we can simply build our REST server composing
our already defined services. Servant’s type wizardy ensures the
expected type for the whole API is matched by actual functions composed
with <code>(:&lt;|&gt;)</code>.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>handler <span class="ot">=</span> getCounter <span class="op">:&lt;|&gt;</span> increment <span class="op">:&lt;|&gt;</span> decrement</span></code></pre></div>
<p>Writing a <code>main</code> server that is able to listen on some
port and runs our services is left as an exercise for the reader.</p>
<h1 id="conclusion">Conclusion</h1>
<p>The goal of this post and the associated talk was to demonstrate how
Haskell’s type system and some well designed and though out libraries
made it easy to build type-safe “microservices”. In particular, I would
like to emphasize the following points:</p>
<ul>
<li>Haskell’s pure functional core makes it a perfect fit for designing,
implementing and experimenting business domain models using <em>Domain
Driven Design</em> principles: Use a common language which here is
embedded in the form of commands, events and errors, provide a pure core
which implements core business rules and can be very easily tested, wrap
that pure core within a <em>Hexagonal architecture</em> providing needed
side-effects…</li>
<li>QuickCheck is a great tool for doing <em>Test Driven
Development</em> of such models: One can use it to expose assumptions
about the behaviour of the model’s clients in the form of
<em>Arbitrary</em> instances and then test potentially complex sequences
of actions against the model,</li>
<li>Using monadic QuickCheck, it is possible to leverage that technique
at any level of the system’s stack, making it easy to test various
effects of our system and how it interacts with the outside world.
Something that we could introduce here is testing the server with
multiple concurrent clients and then checking our model doesn’t break
its invariants in the face of concurrent accesses,</li>
<li>The <em>Extensible effects</em> framework allows us to define and
compose tiny effectful “DSLs” over the core domain DSL. More
importantly, thanks to its extensibility, it is possible to define new
effects without having to recompile any of our existing services (note
this would require our services’ types to be more lax, using typeclass
constraints instead of concrete type for the <em>Eff</em> monad).</li>
</ul>


<div id="disqus_thread"></div>
<script>
  (function() {  // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');

    s.src = '//arnaudsblog.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </div>
    <footer>
       <a href="https://fr.linkedin.com/in/arnaudbailly"> <img src="/images/linkedin.png" width="28" /></a>  <a href="https://twitter.com/dr_c0d3"> <img width="32" src="/images/twitter.png" /></a>  <a href="/atom.xml"><img src="/images/feed-icon.svg" width="24px" /></a>  <a href="http://jaspervdj.be/hakyll"><img src="/images/lambda.png" width="24px" /></a>
    </footer>

  </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42631907-2', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
