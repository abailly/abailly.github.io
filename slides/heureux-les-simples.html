<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">


<meta name="author" content="arnaud.bailly@iohk.io - @dr_c0d3" />


<meta name="dcterms.date" content="September 20, 2022" />

	<title>Blessed are the poor in spirit</title>

		<link rel="stylesheet" href="/reveal.js/reset.css">
		<link rel="stylesheet" href="/reveal.js/reveal.css">
		<link rel="stylesheet" href="/reveal.js/theme/serif-black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="/reveal.js/plugin/highlight/monokai.css" id="highlight-theme">

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<h1 id="intro">Intro</h1>
<h2 id="agenda">Agenda</h2>
<ul class="incremental">
<li>Quick recap about <em>Free monads</em></li>
<li>My experience using such <em>Effects systems</em></li>
<li>My two cents on how to deal with effects</li>
</ul>
<h2 id="background">Background</h2>
<p><img src="/images/jack-of-all-trades.jpg" /></p>
<h2 id="background-1">Background</h2>
<ul class="incremental">
<li>25+ years of professional development</li>
<li>20+ years hacking Haskell</li>
<li>Currently working at <a href="https://iohk.io">Input Output Global</a>, the makers of <a href="https://cardanofoundation.org/">Cardano</a></li>
</ul>
<h1 id="side-effects-in-a-pure-language">Side-Effects in a Pure Language</h1>
<h2 id="motivating-example">Motivating Example</h2>
<p>Let’s assume one has a nice little component providing an interface to manage a nuclear arsenal. This component allows to:</p>
<ul class="incremental">
<li><em>Launch missiles</em> immediately</li>
<li><em>Set DefCon</em> level to some value</li>
<li><em>Get</em> current <em>DefCon</em> level value</li>
</ul>
<h2 id="io-based-interface">IO-based Interface</h2>
<p>In the beginning, there came the <code>IO</code> monad <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math> <a href="">Tackling the Awkward Squad</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">launchMissiles ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">setDefCon ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">getDefCon ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<h2 id="the-problem">The Problem</h2>
<ul class="incremental">
<li><code>IO</code> is too general, anything can happen in a function returning <code>IO a</code></li>
<li>We want consumers of an interface to not have to bother about its <em>implementation</em>’s side-effects</li>
<li>We want the <em>types</em> to help us provide <em>guarantees</em> about side-effects a function is having</li>
</ul>
<h1 id="free-monad-based-effects-handling">Free-monad Based Effects handling</h1>
<h2 id="the-free-monad-approach">The Free Monad Approach</h2>
<ul class="incremental">
<li>Let’s restrict the <em>effects</em> we can make <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math> Define a <em>Domain-Specific Language</em></li>
<li>Define DSL through an <em>Algebraic Data Type</em> representing all the possible <em>actions</em></li>
<li>Apply <em>Free monad</em> construction to be able to embed this language as <em>monadic</em> code</li>
</ul>
<h2 id="canonical-encoding">Canonical Encoding</h2>
<p>Define an <em>Effect language</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Command</span> a <span class="ot">=</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>     <span class="dt">LaunchMissiles</span> <span class="dt">Timeout</span> (() <span class="ot">-&gt;</span> a)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span> <span class="dt">GetDefCon</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)</span></code></pre></div>
<hr />
<p>Turn our language into a <em>Monad</em> and add smart constructors:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CommandM</span> <span class="ot">=</span> <span class="dt">Free</span> <span class="dt">Command</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">launchMissiles ::</span> <span class="dt">Timeout</span> <span class="ot">-&gt;</span> <span class="dt">CommandM</span> ()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>launchMissiles t <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">LaunchMissiles</span> t identity</span></code></pre></div>
<hr />
<p>Provide an interpreter for our language:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpreter ::</span> <span class="dt">CommandM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>interpreter <span class="ot">=</span> iterM runCommand</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    runCommand (<span class="dt">LaunchMissiles</span> f) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>       actuallyLaunchMissilesInIO</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>       f ()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<h2 id="composing-effects">Composing Effects</h2>
<ul class="incremental">
<li>Having a <em>monolithic</em> language is not desirable</li>
<li>We need a way to <em>compose</em> smaller building blocks</li>
<li><em>Vertically</em>, by interpreting one language into another, lower-level language</li>
<li><em>Horizontally</em>, by mixing different languages to solve a complex problem</li>
</ul>
<h2 id="free-monad-zoo">Free-Monad Zoo</h2>
<ul class="incremental">
<li>Different (more efficient) encodings have been proposed</li>
<li>Lots of effects libraries in Haskell: <a href="https://hackage.haskell.org/package/free">free</a>, <a href="https://hackage.haskell.org/package/freer-simple">freer-simple</a>, <a href="https://hackage.haskell.org/package/extensible-effects">extensible-effects</a>, <a href="https://hackage.haskell.org/package/polysemy">polysemy</a>, <a href="https://hackage.haskell.org/package/fused-effects">fused-effects</a>…</li>
<li>Lot of vocal advocates: <a href="https://graninas.com/functional-design-and-architecture-book/">Alexander Granin’s book</a>, <a href="https://reasonablypolymorphic.com/blog/freer-monads/">Sandy Maguire’s blog</a>, <a href="https://www.youtube.com/watch?v=uIRHYMDsDQ0">Arnaud Bailly’s <em>Eff in Anger</em></a>…</li>
</ul>
<h1 id="in-practice">In practice</h1>
<h2 id="take-1-free-co-free">Take 1: Free &amp; Co-free</h2>
<ul class="incremental">
<li><a href="https://github.com/abailly/hdo">hdo</a>, a tool for controlling <a href="https://www.digitalocean.com/">DigitalOcean</a> resources</li>
<li>Early attempt at designing and building a useful tool using this technique</li>
<li>Made more complicated than needed because of use of Free/Co-Free duality</li>
</ul>
<h2 id="outcome">Outcome</h2>
<ul class="incremental">
<li>Lot of boilerplate: Each sub-language came in 2 flavors:
<ul class="incremental">
<li>As a <em>Sum</em> to express individual actions and compose them</li>
<li>As a <em>Product</em> to express interpreter for each action</li>
</ul></li>
<li>Unclear what the value of the Co-free stuff is…</li>
<li>Yet I had <em>1</em> external contribution!</li>
</ul>
<h2 id="take-2-extensible-effects">Take 2: Extensible Effects</h2>
<ul class="incremental">
<li><em>Gorilla Space</em>: an attempt at building an “exchange” for commercial space</li>
<li>Used <em>extensible-effects</em> as a foundation for <em>System level</em> effects (<code>State</code>, <code>Persist</code>, <code>WebServer</code>) embedded inside <a href="https://hackage.haskell.org/package/servant">servant’s</a> type-level combinators for web API</li>
<li>Added ideas from <em>event sourcing</em> and <em>miniservices</em></li>
</ul>
<hr />
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EventStore</span> a <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Eff</span> (<span class="dt">State</span> <span class="dt">Listing</span> <span class="op">:&gt;</span> <span class="dt">Log</span> <span class="dt">LogListing</span> <span class="op">:&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>         <span class="dt">Exc</span> <span class="dt">ServantErr</span> <span class="op">:&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>         <span class="dt">Lift</span> <span class="dt">IO</span> <span class="op">:&gt;</span> <span class="dt">Void</span>) a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">addListing ::</span> <span class="dt">Listings</span> <span class="ot">-&gt;</span> <span class="dt">EventStore</span> (<span class="dt">Answer</span> <span class="dt">Listings</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>addListing l <span class="ot">=</span> applyCommand (<span class="dt">Add</span> l) <span class="op">&gt;&gt;=</span> handleResult</span></code></pre></div>
<h2 id="outcome-1">Outcome</h2>
<p><img src="/images/one-ring.jpg" /></p>
<h2 id="outcome-2">Outcome</h2>
<ul class="incremental">
<li>It was kind of OK as most of the complexity was hidden inside low-level layers</li>
<li>I was the sole developer so hard to tell really</li>
<li>Project never took off even though it went live in “demo” mode for a while</li>
</ul>
<h2 id="take-3-freer">Take 3: Freer</h2>
<ul class="incremental">
<li><em>Symbiont</em>: Build a transaction manager for a permissioned blockchain system</li>
<li>Used <em>freer-simple</em> package which is an evolution of <em>extensible-effects</em></li>
<li>Modelled various <em>functional layers</em> of the system as <em>GADTs</em></li>
</ul>
<h2 id="outcome-3">Outcome</h2>
<p><img src="/images/gasworks.jpg" /></p>
<h2 id="outcome-4">Outcome</h2>
<ul class="incremental">
<li>Large stack comprising 8-10 effects, hard to understand type errors, complex wiring due to dependencies between effects</li>
<li>Initial strict layering went bust after a while leading to <em>Big Bull of Mud</em> and IO-creep</li>
<li>Application has been rewritten, see <a href="https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501">here</a> and also <a href="https://medium.com/barely-functional/do-we-need-effects-to-get-abstraction-7d5dc0edfbef">here</a></li>
</ul>
<h2 id="take-4-operational">Take 4: Operational</h2>
<ul class="incremental">
<li><em>Symbiont</em>: Built a flexible system-level testing framework to run tests locally, with docker…</li>
<li>Used <a href="https://hackage.haskell.org/package/operational">operational</a> package which is a “simpler” <em>Free monad</em></li>
<li>Replaced existing script-based ad hoc tests in favour of an “easy” to use scenario-based testing DSL</li>
<li>More details in those <a href="testing-distributed-systems-with-docker.html">slides</a></li>
</ul>
<h2 id="outcome-5">Outcome</h2>
<p><img src="/images/joy.png" /></p>
<h2 id="outcome-6">Outcome</h2>
<ul class="incremental">
<li>Worked out pretty well initially, scaling to cloud execution, spinning up VMs and the like</li>
<li><strong>Problem</strong>: Maintenance! As I moved to other projects, it became harder and harder for others to maintain and extend the tool until it got deprecated.</li>
</ul>
<h2 id="take-5-moar-freer">Take 5: Moar Freer</h2>
<ul class="incremental">
<li><em>IOG</em>: <a href="https://developers.cardano.org/docs/smart-contracts/plutus">Plutus</a> is the Smart Contracts language for Cardano</li>
<li><a href="https://github.com/input-output-hk/plutus-apps/blob/main/plutus-pab/ARCHITECTURE.adoc">Plutus Application Backend</a> is the official framework to build applications with and it’s built with <em>freer</em></li>
<li>I was involved as a <em>user</em> of the framework not an <em>implementor</em> to build a Layer 2 solution on top of Cardano based on Smart Contracts</li>
</ul>
<hr />
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">game ::</span> <span class="dt">AsContractError</span> e <span class="ot">=&gt;</span> <span class="dt">Contract</span> () <span class="dt">GameSchema</span> e ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>game <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    logInfo <span class="op">@</span><span class="dt">Haskell.String</span> <span class="st">&quot;Waiting for guess or lock endpoint...&quot;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    selectList [lock, guess] <span class="op">&gt;&gt;</span> game</span></code></pre></div>
<h2 id="outcome-7">Outcome</h2>
<ul class="incremental">
<li>Better engineered than my previous attempts</li>
<li>Still suffering from same issues: Complex type machinery, rigid framework, complex wiring, hard to test</li>
<li>Steep learning curve for newcomers</li>
</ul>
<h2 id="key-takeaways">Key Takeaways</h2>
<ul class="incremental">
<li>Effect systems introduce an extra layer of indirection which <em>increases</em> cognitive burden instead of <em>decreasing</em> it</li>
<li>Haskell is an <em>big old language</em> so there’s no way to build a truly seamless eDSL <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math> We need to <em>encode</em> effects</li>
<li>DevX is somewhat terrible past the initial amazement</li>
<li>Learning curve is very steep</li>
<li>Compilation time increases significantly</li>
<li>Performance overhead at runtime</li>
</ul>
<hr />
<p>Effect systems are great for solo projects and research papers</p>
<p><img src="/images/pipe-organ-builder.jpg" /></p>
<hr />
<p>They are not so great for large scale development efforts</p>
<p><img src="/images/refinery.jpg" /></p>
<h1 id="in-praise-of-boring-haskell">In Praise of “Boring” Haskell</h1>
<hr />
<p><img src="/images/biface.jpg" /></p>
<hr />
<ul class="incremental">
<li>Haskell and other FP languages have this great <em>design patterns</em> we can leverage</li>
<li>Functions</li>
<li>Functions that take functions as arguments</li>
<li>Functions that return functions as result</li>
</ul>
<hr />
<p><img src="/images/function-universal-patterns.png" /></p>
<hr />
<p><a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html">Handle</a> pattern aka. <em>Record of functions</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Command</span> m <span class="ot">=</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Command</span> {<span class="ot"> launchMissiles ::</span> <span class="dt">Timeout</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>           ,<span class="ot"> getDefCon ::</span> m <span class="dt">Int</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>           }</span></code></pre></div>
<h2 id="use-alternative-languages">Use Alternative Languages</h2>
<p><img src="/images/architecture-junning.jpg" /></p>
<hr />
<ul class="incremental">
<li>Haskell has</li>
</ul>
<h1 id="questions">Questions?</h1>
<p><img src="/images/magritte-pipe.jpg" /></p>
			</div>
		</div>

		<script src="/reveal.js/reveal.js"></script>
		<script src="/reveal.js/plugin/notes/notes.js"></script>
		<!-- <script src="/reveal.js/plugin/markdown/markdown.js"></script> -->
		<script src="/reveal.js/plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				// plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
				plugins: [ RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
